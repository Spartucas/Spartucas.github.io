<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风雪独樵</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Spartucas.github.io/"/>
  <updated>2018-02-07T03:46:54.000Z</updated>
  <id>http://Spartucas.github.io/</id>
  
  <author>
    <name>Spartucas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式演进之路</title>
    <link href="http://Spartucas.github.io/2018/02/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
    <id>http://Spartucas.github.io/2018/02/07/单例模式演进之路/</id>
    <published>2018-02-07T02:03:00.000Z</published>
    <updated>2018-02-07T03:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个Javaer，相信都应该听说过单例模式。单例模式作为对象创建的一种模式，确保某一个类在整个系统中只有一个实例。<br><a id="more"></a></p><h1 id="饿汉式单例类："><a href="#饿汉式单例类：" class="headerlink" title="饿汉式单例类："></a>饿汉式单例类：</h1><p>饿汉式单例类时Java语言里实现最简单的单例类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class EagerSingleton &#123;</span><br><span class="line"></span><br><span class="line">/** 通过静态变量初始化的类实例 */</span><br><span class="line">private static final EagerSingleton instance = new EagerSingleton();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 私有的默认构造子</span><br><span class="line"> */</span><br><span class="line">private EagerSingleton() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取唯一类实例的静态工厂方法</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static EagerSingleton getInstance() &#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由Java语言类的初始化顺序可知，在这个类被加载时，静态变量会被初始化，此时类的私有构造器会被调用。这时候，单例类的唯一实例就被创建出来了。Java语言中单例类的一个最重要的特点是类的构造器是私有的，从而避免外界使用构造器直接创建出任意多该类的实例。</p><h1 id="懒汉式单例类："><a href="#懒汉式单例类：" class="headerlink" title="懒汉式单例类："></a>懒汉式单例类：</h1><h2 id="懒汉式单例第一版："><a href="#懒汉式单例第一版：" class="headerlink" title="懒汉式单例第一版："></a>懒汉式单例第一版：</h2><p>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  //私有构造函数</span><br><span class="line">    private static Singleton instance = null;  //单例对象</span><br><span class="line">    //静态工厂方法</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式单例类在第一次调用getInstance()方法时创建该对象，遗憾的是这种写法在多线程环境下是不是线程安全的。为什么这么说呢？<br>假设Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法，因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作。<br>这样一来，显然instance被构建了两次。接下来，让我们对代码做一下修改。</p><h2 id="懒汉式单例第二版："><a href="#懒汉式单例第二版：" class="headerlink" title="懒汉式单例第二版："></a>懒汉式单例第二版：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  //私有构造函数</span><br><span class="line">   private static Singleton instance = null;  //单例对象</span><br><span class="line">   //静态工厂方法</span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;      //双重检测机制</span><br><span class="line">         synchronized (Singleton.class)&#123;  //同步锁</span><br><span class="line">           if (instance == null) &#123;     //双重检测机制</span><br><span class="line">             instance = new Singleton();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样写呢？我们来解释几个关键点：<br>首先，为了防止new Singleton被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。<br>然后，进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。像这样两次判空的机制叫做双重检测机制。</p><p><strong> 这样的代码是不是就万无一失，绝对的线程安全了呢？</strong><br>假设这样的场景，当两个线程一先一后访问getInstance方法的时候，当A线程正在构建对象，B线程刚刚进入方法：<br><img src="/img/单例1.png" alt=""><br>这种情况表面看似没什么问题，要么Instance还没被线程A构建，线程B执行 if（instance == null）的时候得到false；要么Instance已经被线程A构建完成，线程B执行 if（instance == null）的时候得到true。</p><p>真的如此吗？答案是否定的。这里涉及到了JVM编译器的指令重排。</p><p>指令重排是什么意思呢？比如java中简单的一句 instance = new Singleton，会被编译器编译成如下JVM指令：</p><p>memory =allocate();    //1：分配对象的内存空间<br>ctorInstance(memory);  //2：初始化对象<br>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>但是这些指令顺序并非一成不变，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：</p><p>memory =allocate();    //1：分配对象的内存空间<br>instance =memory;     //3：设置instance指向刚分配的内存地址<br>ctorInstance(memory);  //2：初始化对象 </p><p>当线程A执行完1,3,时，instance对象还未完成初始化，但已经不再指向null。此时如果线程B抢占到CPU资源，执行  if（instance == nunull）的结果会是false，从而返回一个没有初始化完成的instance对象。如下图所示：<br><img src="/img/单例2.png" alt=""><br><img src="/img/单例3.jpg" alt=""><br>如何避免这一情况呢？我们需要在instance对象前面增加一个修饰符<strong> volatile </strong>。</p><h2 id="懒汉式单例第三版："><a href="#懒汉式单例第三版：" class="headerlink" title="懒汉式单例第三版："></a>懒汉式单例第三版：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;  //私有构造函数</span><br><span class="line">   private volatile static Singleton instance = null;  //单例对象</span><br><span class="line">   //静态工厂方法</span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">       if (instance == null) &#123;      //双重检测机制</span><br><span class="line">       synchronized (this)&#123;  //同步锁</span><br><span class="line">         if (instance == null) &#123;     //双重检测机制</span><br><span class="line">           instance = new Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个volatile是什么鬼呢？<br>简单来说，这个volatile修饰符其中一个作用是阻止了变量访问前后的指令重排，保证了指令执行顺序。另外，volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。<br>经过volatile的修饰，当线程A执行instance = new Singleton的时候，JVM执行顺序是什么样？始终保证是下面的顺序：</p><p>memory =allocate();    //1：分配对象的内存空间<br>ctorInstance(memory);  //2：初始化对象<br>instance =memory;     //3：设置instance指向刚分配的内存地址 </p><p>如此在线程B看来，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。<br>该实现方式有几个值得注意的技术点：<br>首先，使用双重锁检测机制，确保并发情况下instance对象不会被重复初始化。<br>其次使用volatile修饰符，防止指令重排引发的初始化问题。<br>这个实现方式虽然保证了线程安全，但仍然存在一些缺陷，如何写出更优雅的单例模式呢？</p><h2 id="懒汉式单例第四版"><a href="#懒汉式单例第四版" class="headerlink" title="懒汉式单例第四版:"></a>懒汉式单例第四版:</h2><p><strong>用静态内部类实现单例模式：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class LazyHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton ()&#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有几个需要注意的点：</p><p>首选，从外部无法访问静态内部类LazyHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。<br>然后，INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。</p><p>这种方式虽然更简洁，然后也存在着单例模式共同的问题：<br><strong>无法防止利用反射来重复构建对象。</strong><br>在提出解决方案之前，我们先来看看如何通过反射来打破单例模式只能创建一个对象实例的约束。</p><p><strong>利用反射打破单例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获得构造器</span><br><span class="line">Constructor con = Singleton.class.getDeclaredConstructor();</span><br><span class="line">//设置为可访问</span><br><span class="line">con.setAccessible(true);</span><br><span class="line">//构造两个不同的对象</span><br><span class="line">Singleton singleton1 = (Singleton)con.newInstance();</span><br><span class="line">Singleton singleton2 = (Singleton)con.newInstance();</span><br><span class="line">//验证是否是不同对象</span><br><span class="line">System.out.println(singleton1.equals(singleton2));</span><br></pre></td></tr></table></figure></p><p>代码可以简单归纳为三个步骤：<br>第一步，获得单例类的构造器。<br>第二步，把构造器设置为可访问。<br>第三步，使用newInstance方法构造对象。</p><p>最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑问，比较结果是false。</p><p>那有什么方法可以阻止反射的构建方式呢？</p><h1 id="用枚举实现单例模式："><a href="#用枚举实现单例模式：" class="headerlink" title="用枚举实现单例模式："></a>用枚举实现单例模式：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用enum语法糖，JVM会阻止反射获取枚举类的私有构造方法，而且可以保证线程安全。<br>不过这种方式也有唯一的缺点，就是并非使用懒加载，其单例对象是在枚举类被加载的时候进行初始化的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文总结了单例模式的多种写法，旨在加强记忆，回顾学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个Javaer，相信都应该听说过单例模式。单例模式作为对象创建的一种模式，确保某一个类在整个系统中只有一个实例。&lt;br&gt;
    
    </summary>
    
      <category term="design patterns" scheme="http://Spartucas.github.io/categories/design-patterns/"/>
    
    
      <category term="design patterns" scheme="http://Spartucas.github.io/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>REST请求上传文件遇到的坑</title>
    <link href="http://Spartucas.github.io/2018/02/06/REST%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://Spartucas.github.io/2018/02/06/REST请求上传文件遇到的坑/</id>
    <published>2018-02-06T10:03:22.000Z</published>
    <updated>2018-02-06T10:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次开发过程中遇到的问题及解决过程，理清思路避免再犯。<br><a id="more"></a></p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>前段时间在做一个后台管理系统时，使用了REST风格的请求。由于前端页面使用的是JSP,而JSP的form表单提交时只支持get和post动作，因此我们常用的做法是在form表单中埋下一个隐藏的input域，name为要请求的动作。形如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后在web.xml中配置一个解析这种请求动作的过滤器HiddenHttpMethodFilter，和对文件输入流解析的MultipartFilter，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.multipart.support.MultipartFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;multipartResolverBeanName&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;multipartResolver&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>as we all konw,我们还需要在spring配置文件中配置一个上传文件解析器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; </span><br><span class="line">     &lt;property name=&quot;maxUploadSize&quot; value=&quot;20000000&quot;/&gt;</span><br><span class="line">     &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>一切看似大功告成，当我点击上传图片时，却看到这样的提示：</p><blockquote><p>Message JSPs only permit GET POST or HEAD</p></blockquote><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>明明所有的配置都配过了，怎么还提示只允许 GET POST or HEAD动作呢？<br>没办法，只好一步步打断点调试跟代码了…<br>当断点进入MultipartFilter这个类的lookupMultipartResolver()方法，完整方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected MultipartResolver lookupMultipartResolver() &#123;</span><br><span class="line">WebApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">String beanName = getMultipartResolverBeanName();</span><br><span class="line">if (wac != null &amp;&amp; wac.containsBean(beanName)) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Using MultipartResolver &apos;&quot; + beanName + &quot;&apos; for MultipartFilter&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return wac.getBean(beanName, MultipartResolver.class);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return this.defaultMultipartResolver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到<code>WebApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</code>这行代码，就瞬间明白了，<br>在<a href="https://spartucas.github.io/2018/01/23/Spring根上下文与子上下文解析/#more">Spring根上下文与子上下文解析</a>一文中，我们有提到：<code>getWebApplicationContext(ServletContext)</code>得到的是spring的父上下文，而父上下文加载的是web.xml中<code>&lt;context-param&gt;</code>标签下配置的bean，当我们不配置的话则父上下文为空，根据lookupMultipartResolver方法可知，当wac为空时，返回的是默认的defaultMultipartResolver类，而不是我们自己配置的multipartResolver。</p><p><strong> 那该怎么解决呢？</strong><br>很简单，把我们需要的multipartResolver解析Bean配置在一个由<context-param>加载的配置文件中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:spring/root-context.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure></context-param></p><p>其中root-context.xml中只配置了我们的multipartResolver解析器，这样multipartResolver解析器就被加载进我们的父上下文中了，然后也可以被MultipartFilter获取到了。问题解决！</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>记录一次开发过程中遇到的问题及解决过程，避免下次在同一个坑跌倒。同时在记录的过程中又加深了印象，理解程度又进一步，可能这就是写博客的好处吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次开发过程中遇到的问题及解决过程，理清思路避免再犯。&lt;br&gt;
    
    </summary>
    
      <category term="loveBugs" scheme="http://Spartucas.github.io/categories/loveBugs/"/>
    
    
      <category term="loveBugs" scheme="http://Spartucas.github.io/tags/loveBugs/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP长连接与短连接</title>
    <link href="http://Spartucas.github.io/2018/02/06/%E8%B0%88%E8%B0%88HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://Spartucas.github.io/2018/02/06/谈谈HTTP长连接与短连接/</id>
    <published>2018-02-06T04:36:07.000Z</published>
    <updated>2018-02-06T04:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前就听说过http长连接和短连接，一直没有彻底弄清楚过，感觉懵懵懂懂。<br>今天在学习websocket的时候又听到了这个概念，于是决定不能再懵懂下去了。经过一番研究，下面是我的一些理解。<br><a id="more"></a></p><h1 id="一个误区"><a href="#一个误区" class="headerlink" title="一个误区"></a>一个误区</h1><p>我们知道，客户端发起一次HTTP请求，经过服务端响应返回后，本次HTTP请求就结束了，那么HTTP长连接到底说的是什么呢？其实这里的长连接短连接，本质上说的是TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。<br>另外，HTTP1.0协议是不支持长连接的，从HTTP1.1协议以后，连接默认都是长连接。</p><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><p>首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？<br>如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？如果是普通的web应用，比如打开一个博客浏览文章，我们通常不会很频繁的发送请求，那我们应用这种长连接有什么用？</p><p>当我们明白长连接其实 是指TCP的连接后，这些问题就瞬间明白了。<br>第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？<br>当然是，但要服务器和客户端都设置。<br>第二个问题是，我们平时用的是不是长连接？<br>这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）<br>第三个问题，像一般的web应用（如博客）使用长连接有什么好处？是否需要关掉长连接而使用短连接？<br>肯定的回答，当然有好处。<br>长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。比如你请求了博客的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用多说了吧。但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。<br>另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间 keep-alive timeout），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。<br>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。<br>这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住 keepalive_timeout秒后，才开始关闭这个连接。当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是 keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来http请求，则关闭这个TCP连接。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好记性不如赖笔头。写下这篇文章是为整理脑中知识的同时也为了避免遗忘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早以前就听说过http长连接和短连接，一直没有彻底弄清楚过，感觉懵懵懂懂。&lt;br&gt;今天在学习websocket的时候又听到了这个概念，于是决定不能再懵懂下去了。经过一番研究，下面是我的一些理解。&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://Spartucas.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://Spartucas.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Spring根上下文与子上下文解析</title>
    <link href="http://Spartucas.github.io/2018/01/23/Spring%E6%A0%B9%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E5%AD%90%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%A3%E6%9E%90/"/>
    <id>http://Spartucas.github.io/2018/01/23/Spring根上下文与子上下文解析/</id>
    <published>2018-01-23T09:47:58.000Z</published>
    <updated>2018-01-23T11:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> spring的启动过程其实就是其IoC容器的启动过程，对于web程序，IoC容器启动过程即是建立上下文的过程。 </strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h1 id="Spring的启动过程："><a href="#Spring的启动过程：" class="headerlink" title="Spring的启动过程："></a>Spring的启动过程：</h1><p>首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；</p><p>其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；</p><p>再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。</p><p>摘要: Spring 容器最基本的接口就是BeanFactory。项目开发中会涉及到父子上下文的概念。<br>最近在做项目时牵扯到有关父子上下文的概念。</p><h1 id="何为父子上下文呢？"><a href="#何为父子上下文呢？" class="headerlink" title="何为父子上下文呢？"></a>何为父子上下文呢？</h1><ul><li>父上下文：</li></ul><p>使用listener监听器来加载配置文件，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;   </span><br><span class="line">  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;   </span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><p>Spring 会创建一个WebApplicationContext上下文，称为父上下文（父容器），保存在 ServletContext中，key是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值。</p><p>可以使用Spring提供的工具类取出上下文对象：<br>WebApplicationContextUtils.getWebApplicationContext(ServletContext);</p><ul><li>子上下文：</li></ul><p>使用Spring MVC 来处理拦截相关的请求时，会配置DispatchServlet：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    &lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;/WEB-INF/applicationContext-mvc.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>每个DispatchServlet会有一个自己的上下文，称为子上下文，它也保存在 ServletContext中，key 是”org.springframework.web.servlet.FrameworkServlet.CONTEXT”+Servlet名称。当一 个Request对象产生时，会把这个子上下文对象（WebApplicationContext）保存在Request对象中，key是 DispatcherServlet.class.getName() + “.CONTEXT”。<br>可以使用工具类取出上下文对象：RequestContextUtils.getWebApplicationContext(request);</p><h1 id="父上下文（父容器）和子上下文（子容器）的访问权限："><a href="#父上下文（父容器）和子上下文（子容器）的访问权限：" class="headerlink" title="父上下文（父容器）和子上下文（子容器）的访问权限："></a>父上下文（父容器）和子上下文（子容器）的访问权限：</h1><p>子上下文可以访问父上下文中的bean，但是父上下文不可以访问子上下文中的bean。</p><h1 id="父上下文使用与否"><a href="#父上下文使用与否" class="headerlink" title="父上下文使用与否"></a>父上下文使用与否</h1><ul><li>方案一，传统型：</li></ul><p>父上下文容器中保存数据源、服务层、DAO层、事务的Bean。</p><p>子上下文容器中保存Mvc相关的Action的Bean.</p><p>事务控制在服务层。</p><p>由于父上下文容器不能访问子上下文容器中内容，事务的Bean在父上下文容器中，无法访问子上下文容器中内容，就无法对子上下文容器中Action进行AOP（事务）。</p><p>当然，做为“传统型”方案，也没有必要这要做。</p><ul><li>方案二，激进型：</li></ul><p>Java世界的“面向接口编程”的思想是正确的，但在增删改查为主业务的系统里，Dao层接口，Dao层实现类，Service层接口，Service层实现类，Action父类，Action。再加上众多的O(vo\po\bo)和jsp页面。写一个小功能 7、8个类就写出来了。 开发者说我就是想接点私活儿，和PHP，ASP抢抢饭碗，但我又是Java程序员。最好的结果是大项目能做好，小项目能做快。所以“激进型”方案就出现了—–没有接口、没有Service层、还可以没有众多的O(vo\po\bo)。那没有Service层事务控制在哪一层？只好上升的Action层。</p><p>本文不想说这是不是正确的思想，我想说的是Spring不会限制你这样做。</p><p>由于有了父子上下文，你将无法实现这一目标。解决方案是只使用子上下文容器，不要父上下文容器 。所以数据源、服务层、DAO层、事务的Bean、Action的Bean都放在子上下文容器中。就可以实现了，事务（注解事务）就正常工作了。这样才够激进。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p> 不使用listener监听器来加载spring的配置文件，只使用DispatcherServlet来加载spring的配置，不要父子上下文，只使用一个DispatcherServlet，事情就简单了，什么麻烦事儿也没有了。</p><p>Java–大项目能做好–按传统方式做，规规矩矩的做，好扩展，好维护。<br>Java–小项目能做快–按激进方式做，一周时间就可以出一个版本，先上线接受市场(用户)的反馈，再改进，再反馈，时间就是生命(成本)。 </p><p>转载自：<a href="https://www.jianshu.com/p/b3eab5acc7f4" target="_blank" rel="noopener">https://www.jianshu.com/p/b3eab5acc7f4</a><br>ps：感谢原文作者，此处转载仅供自己学习整理使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; spring的启动过程其实就是其IoC容器的启动过程，对于web程序，IoC容器启动过程即是建立上下文的过程。 &lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://Spartucas.github.io/categories/Spring/"/>
    
    
      <category term="hexo" scheme="http://Spartucas.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
