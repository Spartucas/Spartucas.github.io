<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风雪独樵</title>
  
  <subtitle>少年听雨阁楼上，红烛昏罗帐。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Spartucas.github.io/"/>
  <updated>2018-02-06T10:09:32.000Z</updated>
  <id>http://Spartucas.github.io/</id>
  
  <author>
    <name>Spartucas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>REST请求上传文件遇到的坑</title>
    <link href="http://Spartucas.github.io/2018/02/06/REST%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://Spartucas.github.io/2018/02/06/REST请求上传文件遇到的坑/</id>
    <published>2018-02-06T10:03:22.000Z</published>
    <updated>2018-02-06T10:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次开发过程中遇到的问题及解决过程，理清思路避免再犯。<br><a id="more"></a></p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>前段时间在做一个后台管理系统时，使用了REST风格的请求。由于前端页面使用的是JSP,而JSP的form表单提交时只支持get和post动作，因此我们常用的做法是在form表单中埋下一个隐藏的input域，name为要请求的动作。形如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后在web.xml中配置一个解析这种请求动作的过滤器HiddenHttpMethodFilter，和对文件输入流解析的MultipartFilter，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.multipart.support.MultipartFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;multipartResolverBeanName&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;multipartResolver&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>as we all konw,我们还需要在spring配置文件中配置一个上传文件解析器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; </span><br><span class="line">     &lt;property name=&quot;maxUploadSize&quot; value=&quot;20000000&quot;/&gt;</span><br><span class="line">     &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>一切看似大功告成，当我点击上传图片时，却看到这样的提示：</p><blockquote><p>Message JSPs only permit GET POST or HEAD</p></blockquote><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>明明所有的配置都配过了，怎么还提示只允许 GET POST or HEAD动作呢？<br>没办法，只好一步步打断点调试跟代码了…<br>当断点进入MultipartFilter这个类的lookupMultipartResolver()方法，完整方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected MultipartResolver lookupMultipartResolver() &#123;</span><br><span class="line">WebApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">String beanName = getMultipartResolverBeanName();</span><br><span class="line">if (wac != null &amp;&amp; wac.containsBean(beanName)) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Using MultipartResolver &apos;&quot; + beanName + &quot;&apos; for MultipartFilter&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return wac.getBean(beanName, MultipartResolver.class);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return this.defaultMultipartResolver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到<code>WebApplicationContext wac = WebApplicationContextUtils.getWebApplicationContext(getServletContext());</code>这行代码，就瞬间明白了，<br>在<a href="https://spartucas.github.io/2018/01/23/Spring根上下文与子上下文解析/#more">Spring根上下文与子上下文解析</a>一文中，我们有提到：<code>getWebApplicationContext(ServletContext)</code>得到的是spring的父上下文，而父上下文加载的是web.xml中<code>&lt;context-param&gt;</code>标签下配置的bean，当我们不配置的话则父上下文为空，根据lookupMultipartResolver方法可知，当wac为空时，返回的是默认的defaultMultipartResolver类，而不是我们自己配置的multipartResolver。</p><p><strong> 那该怎么解决呢？</strong><br>很简单，把我们需要的multipartResolver解析Bean配置在一个由<context-param>加载的配置文件中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:spring/root-context.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure></context-param></p><p>其中root-context.xml中只配置了我们的multipartResolver解析器，这样multipartResolver解析器就被加载进我们的父上下文中了，然后也可以被MultipartFilter获取到了。问题解决！</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>记录一次开发过程中遇到的问题及解决过程，避免下次在同一个坑跌倒。同时在记录的过程中又加深了印象，理解程度又进一步，可能这就是写博客的好处吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次开发过程中遇到的问题及解决过程，理清思路避免再犯。&lt;br&gt;
    
    </summary>
    
      <category term="loveBugs" scheme="http://Spartucas.github.io/categories/loveBugs/"/>
    
    
      <category term="loveBugs" scheme="http://Spartucas.github.io/tags/loveBugs/"/>
    
  </entry>
  
  <entry>
    <title>谈谈HTTP长连接与短连接</title>
    <link href="http://Spartucas.github.io/2018/02/06/%E8%B0%88%E8%B0%88HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://Spartucas.github.io/2018/02/06/谈谈HTTP长连接与短连接/</id>
    <published>2018-02-06T04:36:07.000Z</published>
    <updated>2018-02-06T04:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前就听说过http长连接和短连接，一直没有彻底弄清楚过，感觉懵懵懂懂。<br>今天在学习websocket的时候又听到了这个概念，于是决定不能再懵懂下去了。经过一番研究，下面是我的一些理解。<br><a id="more"></a></p><h1 id="一个误区"><a href="#一个误区" class="headerlink" title="一个误区"></a>一个误区</h1><p>我们知道，客户端发起一次HTTP请求，经过服务端响应返回后，本次HTTP请求就结束了，那么HTTP长连接到底说的是什么呢？其实这里的长连接短连接，本质上说的是TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。其实知道了以后，会觉得这很好理解。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。<br>另外，HTTP1.0协议是不支持长连接的，从HTTP1.1协议以后，连接默认都是长连接。</p><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><p>首先是怎么样就算是把HTTP变成长连接了，是不是只要设置Connection为keep-alive就算是了？<br>如果是的话，那都说HTTP1.1默认是长连接，而观察我们平时开发的Web应用的HTTP头部，Connection也确实是keep-alive，那就是说我们大部分都是用的长连接，但是长连接不是一般用于交互比较频繁的应用吗？如果是普通的web应用，比如打开一个博客浏览文章，我们通常不会很频繁的发送请求，那我们应用这种长连接有什么用？</p><p>当我们明白长连接其实 是指TCP的连接后，这些问题就瞬间明白了。<br>第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？<br>当然是，但要服务器和客户端都设置。<br>第二个问题是，我们平时用的是不是长连接？<br>这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive）<br>第三个问题，像一般的web应用（如博客）使用长连接有什么好处？是否需要关掉长连接而使用短连接？<br>肯定的回答，当然有好处。<br>长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。比如你请求了博客的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用多说了吧。但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。<br>另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间 keep-alive timeout），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。<br>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。<br>这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住 keepalive_timeout秒后，才开始关闭这个连接。当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是 keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览发过来http请求，则关闭这个TCP连接。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好记性不如赖笔头。写下这篇文章是为整理脑中知识的同时也为了避免遗忘。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早以前就听说过http长连接和短连接，一直没有彻底弄清楚过，感觉懵懵懂懂。&lt;br&gt;今天在学习websocket的时候又听到了这个概念，于是决定不能再懵懂下去了。经过一番研究，下面是我的一些理解。&lt;br&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://Spartucas.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://Spartucas.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Spring根上下文与子上下文解析</title>
    <link href="http://Spartucas.github.io/2018/01/23/Spring%E6%A0%B9%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E5%AD%90%E4%B8%8A%E4%B8%8B%E6%96%87%E8%A7%A3%E6%9E%90/"/>
    <id>http://Spartucas.github.io/2018/01/23/Spring根上下文与子上下文解析/</id>
    <published>2018-01-23T09:47:58.000Z</published>
    <updated>2018-01-23T11:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> spring的启动过程其实就是其IoC容器的启动过程，对于web程序，IoC容器启动过程即是建立上下文的过程。 </strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h1 id="Spring的启动过程："><a href="#Spring的启动过程：" class="headerlink" title="Spring的启动过程："></a>Spring的启动过程：</h1><p>首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；</p><p>其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；</p><p>再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。</p><p>摘要: Spring 容器最基本的接口就是BeanFactory。项目开发中会涉及到父子上下文的概念。<br>最近在做项目时牵扯到有关父子上下文的概念。</p><h1 id="何为父子上下文呢？"><a href="#何为父子上下文呢？" class="headerlink" title="何为父子上下文呢？"></a>何为父子上下文呢？</h1><ul><li>父上下文：</li></ul><p>使用listener监听器来加载配置文件，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;   </span><br><span class="line">  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;   </span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><p>Spring 会创建一个WebApplicationContext上下文，称为父上下文（父容器），保存在 ServletContext中，key是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的值。</p><p>可以使用Spring提供的工具类取出上下文对象：<br>WebApplicationContextUtils.getWebApplicationContext(ServletContext);</p><ul><li>子上下文：</li></ul><p>使用Spring MVC 来处理拦截相关的请求时，会配置DispatchServlet：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">    &lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;/WEB-INF/applicationContext-mvc.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>每个DispatchServlet会有一个自己的上下文，称为子上下文，它也保存在 ServletContext中，key 是”org.springframework.web.servlet.FrameworkServlet.CONTEXT”+Servlet名称。当一 个Request对象产生时，会把这个子上下文对象（WebApplicationContext）保存在Request对象中，key是 DispatcherServlet.class.getName() + “.CONTEXT”。<br>可以使用工具类取出上下文对象：RequestContextUtils.getWebApplicationContext(request);</p><h1 id="父上下文（父容器）和子上下文（子容器）的访问权限："><a href="#父上下文（父容器）和子上下文（子容器）的访问权限：" class="headerlink" title="父上下文（父容器）和子上下文（子容器）的访问权限："></a>父上下文（父容器）和子上下文（子容器）的访问权限：</h1><p>子上下文可以访问父上下文中的bean，但是父上下文不可以访问子上下文中的bean。</p><h1 id="父上下文使用与否"><a href="#父上下文使用与否" class="headerlink" title="父上下文使用与否"></a>父上下文使用与否</h1><ul><li>方案一，传统型：</li></ul><p>父上下文容器中保存数据源、服务层、DAO层、事务的Bean。</p><p>子上下文容器中保存Mvc相关的Action的Bean.</p><p>事务控制在服务层。</p><p>由于父上下文容器不能访问子上下文容器中内容，事务的Bean在父上下文容器中，无法访问子上下文容器中内容，就无法对子上下文容器中Action进行AOP（事务）。</p><p>当然，做为“传统型”方案，也没有必要这要做。</p><ul><li>方案二，激进型：</li></ul><p>Java世界的“面向接口编程”的思想是正确的，但在增删改查为主业务的系统里，Dao层接口，Dao层实现类，Service层接口，Service层实现类，Action父类，Action。再加上众多的O(vo\po\bo)和jsp页面。写一个小功能 7、8个类就写出来了。 开发者说我就是想接点私活儿，和PHP，ASP抢抢饭碗，但我又是Java程序员。最好的结果是大项目能做好，小项目能做快。所以“激进型”方案就出现了—–没有接口、没有Service层、还可以没有众多的O(vo\po\bo)。那没有Service层事务控制在哪一层？只好上升的Action层。</p><p>本文不想说这是不是正确的思想，我想说的是Spring不会限制你这样做。</p><p>由于有了父子上下文，你将无法实现这一目标。解决方案是只使用子上下文容器，不要父上下文容器 。所以数据源、服务层、DAO层、事务的Bean、Action的Bean都放在子上下文容器中。就可以实现了，事务（注解事务）就正常工作了。这样才够激进。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p> 不使用listener监听器来加载spring的配置文件，只使用DispatcherServlet来加载spring的配置，不要父子上下文，只使用一个DispatcherServlet，事情就简单了，什么麻烦事儿也没有了。</p><p>Java–大项目能做好–按传统方式做，规规矩矩的做，好扩展，好维护。<br>Java–小项目能做快–按激进方式做，一周时间就可以出一个版本，先上线接受市场(用户)的反馈，再改进，再反馈，时间就是生命(成本)。 </p><p>转载自：<a href="https://www.jianshu.com/p/b3eab5acc7f4" target="_blank" rel="noopener">https://www.jianshu.com/p/b3eab5acc7f4</a><br>ps：感谢原文作者，此处转载仅供自己学习整理使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; spring的启动过程其实就是其IoC容器的启动过程，对于web程序，IoC容器启动过程即是建立上下文的过程。 &lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://Spartucas.github.io/categories/Spring/"/>
    
    
      <category term="hexo" scheme="http://Spartucas.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
